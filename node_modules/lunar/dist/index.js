// src/errors.ts
var LunarError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LunarError";
  }
};
var InvalidLunarDateError = class extends LunarError {
  constructor(message) {
    super(message);
    this.name = "InvalidLunarDateError";
  }
};
var InvalidGregorianDateError = class extends LunarError {
  constructor(message) {
    super(message);
    this.name = "InvalidGregorianDateError";
  }
};
var NotImplementedError = class extends LunarError {
  constructor(feature) {
    super(`${feature} \u5C1A\u672A\u5B9E\u73B0`);
    this.name = "NotImplementedError";
  }
};

// src/types.ts
var MIN_SUPPORTED_YEAR = 1890;
var MAX_SUPPORTED_YEAR = 2100;

// src/lunar-date.ts
function createLunarDate(input) {
  const normalized = normalizeInput(input);
  const { year, month, day } = normalized;
  validateYear(year);
  validateMonth(month);
  validateDay(day);
  const result = Object.freeze({
    year,
    month,
    day,
    isLeapMonth: normalized.isLeapMonth ?? false
  });
  return result;
}
function normalizeInput(input) {
  if (Array.isArray(input)) {
    const [year, month, day, isLeapMonth] = input;
    return { year, month, day, isLeapMonth };
  }
  return input;
}
function validateYear(year) {
  if (!Number.isInteger(year)) {
    throw new InvalidLunarDateError("\u519C\u5386\u5E74\u4EFD\u5FC5\u987B\u662F\u6574\u6570");
  }
  if (year < MIN_SUPPORTED_YEAR || year > MAX_SUPPORTED_YEAR) {
    throw new InvalidLunarDateError(
      `\u519C\u5386\u5E74\u4EFD\u4EC5\u652F\u6301 ${MIN_SUPPORTED_YEAR}-${MAX_SUPPORTED_YEAR}`
    );
  }
}
function validateMonth(month) {
  if (!Number.isInteger(month)) {
    throw new InvalidLunarDateError("\u519C\u5386\u6708\u4EFD\u5FC5\u987B\u662F\u6574\u6570");
  }
  if (month < 1 || month > 12) {
    throw new InvalidLunarDateError("\u519C\u5386\u6708\u4EFD\u5FC5\u987B\u4F4D\u4E8E 1-12 \u4E4B\u95F4");
  }
}
function validateDay(day) {
  if (!Number.isInteger(day)) {
    throw new InvalidLunarDateError("\u519C\u5386\u65E5\u671F\u5FC5\u987B\u662F\u6574\u6570");
  }
  if (day < 1 || day > 30) {
    throw new InvalidLunarDateError("\u519C\u5386\u65E5\u671F\u5FC5\u987B\u4F4D\u4E8E 1-30 \u4E4B\u95F4");
  }
}

// src/utils/normalize.ts
function normalizeGregorianInput(input) {
  if (input instanceof Date) {
    return ensureValidDate(new Date(input.getTime()));
  }
  if (typeof input === "number") {
    return ensureValidDate(new Date(input));
  }
  if (isPlainObject(input)) {
    return fromFields(input);
  }
  throw new InvalidGregorianDateError("\u65E0\u6CD5\u8BC6\u522B\u7684\u516C\u5386\u8F93\u5165\u683C\u5F0F");
}
function ensureValidDate(date) {
  if (Number.isNaN(date.getTime())) {
    throw new InvalidGregorianDateError("\u65E0\u6548\u7684\u65F6\u95F4\u503C");
  }
  return date;
}
function fromFields({ year, month, day }) {
  if (![year, month, day].every(Number.isInteger)) {
    throw new InvalidGregorianDateError("\u516C\u5386\u5E74\u6708\u65E5\u9700\u4E3A\u6574\u6570");
  }
  if (month < 1 || month > 12) {
    throw new InvalidGregorianDateError("\u516C\u5386\u6708\u4EFD\u9700\u4F4D\u4E8E 1-12 \u4E4B\u95F4");
  }
  if (day < 1 || day > 31) {
    throw new InvalidGregorianDateError("\u516C\u5386\u65E5\u671F\u9700\u4F4D\u4E8E 1-31 \u4E4B\u95F4");
  }
  const candidate = new Date(Date.UTC(year, month - 1, day));
  if (candidate.getUTCFullYear() !== year || candidate.getUTCMonth() !== month - 1 || candidate.getUTCDate() !== day) {
    throw new InvalidGregorianDateError("\u516C\u5386\u65E5\u671F\u4E0D\u5B58\u5728");
  }
  return candidate;
}
function isPlainObject(value) {
  return Boolean(value) && typeof value === "object";
}

// src/data/lunar-data.ts
var DATA_YEAR_MIN = 1890;
var DATA_YEAR_MAX = 2100;
var ENCODED_LUNAR_YEARS = Object.freeze([
  1750378,
  339370,
  6020516,
  405156,
  314698,
  4934293,
  371351,
  279894,
  2804405,
  346837,
  8124114,
  419666,
  331429,
  4961866,
  394827,
  297627,
  3880278,
  370026,
  281433,
  1759058,
  345938,
  6019877,
  412453,
  313931,
  4936875,
  377517,
  288107,
  1764201,
  355753,
  7093650,
  429714,
  331045,
  4954701,
  395862,
  303798,
  3872181,
  370388,
  282281,
  1769106,
  347794,
  6016294,
  402731,
  313943,
  4936374,
  379738,
  296660,
  2821833,
  354121,
  7075475,
  420499,
  329003,
  5991003,
  387757,
  304490,
  3881813,
  371620,
  281417,
  1759891,
  346773,
  7058733,
  402742,
  314029,
  4945322,
  378290,
  290213,
  2825546,
  363850,
  8120981,
  412311,
  329046,
  5999285,
  387797,
  304850,
  3878565,
  372389,
  280138,
  2796695,
  338587,
  7066970,
  402794,
  314217,
  4945746,
  387922,
  289573,
  3864139,
  354891,
  8123563,
  410285,
  320877,
  5999465,
  396713,
  306578,
  3882277,
  372005,
  10246733,
  428630,
  336566,
  6006197,
  403157,
  315049,
  4947602,
  388754,
  298278,
  2812502,
  346711,
  8123606,
  418650,
  321237,
  4953801,
  395081,
  304787,
  3872043,
  361771,
  272987,
  1758554,
  337258,
  7060309,
  412580,
  322377,
  4938387,
  379541,
  288045,
  3861165,
  346805,
  9172394,
  419282,
  331173,
  6004042,
  396618,
  306325,
  3880238,
  361814,
  273077,
  1758642,
  345810,
  6008485,
  403237,
  312907,
  4934807,
  371883,
  288090,
  2812630,
  355177,
  11269970,
  420690,
  330533,
  6003275,
  387659,
  296107,
  4916571,
  361901,
  273258,
  1760082,
  347538,
  7068965,
  404773,
  313941,
  4936877,
  378038,
  279989,
  2813354,
  356041,
  8142482,
  421522,
  331046,
  5999190,
  387671,
  296150,
  3868373,
  362325,
  280393,
  2797203,
  337555,
  7058731,
  402731,
  305755,
  4937050,
  378218,
  289637,
  3864394,
  355146,
  8125077,
  420501,
  320813,
  5991085,
  387765,
  304554,
  3869605,
  363941,
  281930,
  2808981,
  339094,
  7059790,
  402774,
  314037,
  4937138,
  378578,
  290469,
  3870282,
  345675,
  8113303,
  410795,
  320859,
  5991126,
  387946,
  304978,
  3880741,
  363301,
  273035,
  1750171,
  337067
]);
if (ENCODED_LUNAR_YEARS.length !== DATA_YEAR_MAX - DATA_YEAR_MIN + 1) {
  throw new Error("\u519C\u5386\u5E74\u8868\u6570\u636E\u957F\u5EA6\u4E0E\u5E74\u4EFD\u8303\u56F4\u4E0D\u5339\u914D");
}
var LUNAR_MONTH_NAMES = Object.freeze([
  "\u6B63\u6708",
  "\u4E8C\u6708",
  "\u4E09\u6708",
  "\u56DB\u6708",
  "\u4E94\u6708",
  "\u516D\u6708",
  "\u4E03\u6708",
  "\u516B\u6708",
  "\u4E5D\u6708",
  "\u5341\u6708",
  "\u51AC\u6708",
  "\u814A\u6708"
]);
var LUNAR_DAY_NAMES = Object.freeze([
  "",
  "\u521D\u4E00",
  "\u521D\u4E8C",
  "\u521D\u4E09",
  "\u521D\u56DB",
  "\u521D\u4E94",
  "\u521D\u516D",
  "\u521D\u4E03",
  "\u521D\u516B",
  "\u521D\u4E5D",
  "\u521D\u5341",
  "\u5341\u4E00",
  "\u5341\u4E8C",
  "\u5341\u4E09",
  "\u5341\u56DB",
  "\u5341\u4E94",
  "\u5341\u516D",
  "\u5341\u4E03",
  "\u5341\u516B",
  "\u5341\u4E5D",
  "\u4E8C\u5341",
  "\u5EFF\u4E00",
  "\u5EFF\u4E8C",
  "\u5EFF\u4E09",
  "\u5EFF\u56DB",
  "\u5EFF\u4E94",
  "\u5EFF\u516D",
  "\u5EFF\u4E03",
  "\u5EFF\u516B",
  "\u5EFF\u4E5D",
  "\u4E09\u5341"
]);
var HEAVENLY_STEMS = Object.freeze([
  "\u7532",
  "\u4E59",
  "\u4E19",
  "\u4E01",
  "\u620A",
  "\u5DF1",
  "\u5E9A",
  "\u8F9B",
  "\u58EC",
  "\u7678"
]);
var EARTHLY_BRANCHES = Object.freeze([
  "\u5B50",
  "\u4E11",
  "\u5BC5",
  "\u536F",
  "\u8FB0",
  "\u5DF3",
  "\u5348",
  "\u672A",
  "\u7533",
  "\u9149",
  "\u620C",
  "\u4EA5"
]);
var ZODIAC_ANIMALS = Object.freeze([
  "\u9F20",
  "\u725B",
  "\u864E",
  "\u5154",
  "\u9F99",
  "\u86C7",
  "\u9A6C",
  "\u7F8A",
  "\u7334",
  "\u9E21",
  "\u72D7",
  "\u732A"
]);
var SOLAR_TERMS = Object.freeze([
  "\u5C0F\u5BD2",
  "\u5927\u5BD2",
  "\u7ACB\u6625",
  "\u96E8\u6C34",
  "\u60CA\u86F0",
  "\u6625\u5206",
  "\u6E05\u660E",
  "\u8C37\u96E8",
  "\u7ACB\u590F",
  "\u5C0F\u6EE1",
  "\u8292\u79CD",
  "\u590F\u81F3",
  "\u5C0F\u6691",
  "\u5927\u6691",
  "\u7ACB\u79CB",
  "\u5904\u6691",
  "\u767D\u9732",
  "\u79CB\u5206",
  "\u5BD2\u9732",
  "\u971C\u964D",
  "\u7ACB\u51AC",
  "\u5C0F\u96EA",
  "\u5927\u96EA",
  "\u51AC\u81F3"
]);
var SOLAR_TERM_DEGREES = Object.freeze([
  0,
  21208,
  42467,
  63836,
  85337,
  107014,
  128867,
  150921,
  173149,
  195551,
  218072,
  240693,
  263343,
  285989,
  308563,
  331033,
  353350,
  375494,
  397447,
  419210,
  440795,
  462224,
  483532,
  504758
]);

// src/data/year-info.ts
var MONTH_BIT_MASK = (1 << 13) - 1;
var MS_PER_DAY = 864e5;
var cache = /* @__PURE__ */ new Map();
function getYearInfo(year) {
  if (year < DATA_YEAR_MIN || year > DATA_YEAR_MAX) {
    throw new RangeError(`\u519C\u5386\u5E74\u4EC5\u652F\u6301 ${DATA_YEAR_MIN}-${DATA_YEAR_MAX}`);
  }
  if (cache.has(year)) {
    return cache.get(year);
  }
  const encoded = ENCODED_LUNAR_YEARS[year - DATA_YEAR_MIN];
  const hasLeapMonth = Boolean(encoded & 1 << 19);
  const info = {
    year,
    startMonth: encoded >> 18 & 1,
    startDay: encoded >> 13 & 31,
    hasLeapMonth,
    leapMonthIndex: hasLeapMonth ? encoded >> 20 & 15 : null,
    monthBits: encoded & MONTH_BIT_MASK
  };
  cache.set(year, info);
  return info;
}
function getSegmentCount(info) {
  return 12 + (info.hasLeapMonth ? 1 : 0);
}
function getSegmentDays(info, segmentIndex) {
  return info.monthBits & 1 << segmentIndex ? 30 : 29;
}
function getYearStartTimestamp(info) {
  return Date.UTC(info.year, info.startMonth, info.startDay);
}
function diffDaysFromYearStart(date, startTimestamp) {
  return Math.floor((date.getTime() - startTimestamp) / MS_PER_DAY);
}
function getAccumulatedDaysBeforeSegment(info, segmentIndex) {
  let total = 0;
  for (let i = 0; i < segmentIndex; i += 1) {
    total += getSegmentDays(info, i);
  }
  return total;
}

// src/utils/timezone.ts
var dateFormatterCache = /* @__PURE__ */ new Map();
var MS_PER_DAY2 = 864e5;
function toTimeZoneDate(date, timeZone) {
  const parts = getZonedDateParts(date, timeZone);
  return partsToUTC(parts);
}
function alignDateToTimeZone(date, timeZone) {
  const targetParts = {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    day: date.getUTCDate()
  };
  let candidate = partsToUTC(targetParts);
  for (let i = 0; i < 3; i += 1) {
    const zonedParts = getZonedDateParts(candidate, timeZone);
    const diff = dayNumber(targetParts) - dayNumber(zonedParts);
    if (diff === 0) {
      return candidate;
    }
    candidate = new Date(candidate.getTime() + diff * MS_PER_DAY2);
  }
  return candidate;
}
function getZonedDateParts(date, timeZone) {
  var _a, _b, _c;
  const formatter = getDateFormatter(timeZone);
  const parts = formatter.formatToParts(date);
  const year = Number(((_a = parts.find((p) => p.type === "year")) == null ? void 0 : _a.value) ?? NaN);
  const month = Number(((_b = parts.find((p) => p.type === "month")) == null ? void 0 : _b.value) ?? NaN);
  const day = Number(((_c = parts.find((p) => p.type === "day")) == null ? void 0 : _c.value) ?? NaN);
  if (Number.isNaN(year) || Number.isNaN(month) || Number.isNaN(day)) {
    throw new RangeError(`\u65E0\u6CD5\u89E3\u6790 ${timeZone} \u7684\u65E5\u671F`);
  }
  return { year, month, day };
}
function getDateFormatter(timeZone) {
  if (!dateFormatterCache.has(timeZone)) {
    dateFormatterCache.set(
      timeZone,
      new Intl.DateTimeFormat("en-CA", {
        timeZone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      })
    );
  }
  return dateFormatterCache.get(timeZone);
}
function partsToUTC(parts) {
  return new Date(Date.UTC(parts.year, parts.month - 1, parts.day));
}
function dayNumber(parts) {
  return Date.UTC(parts.year, parts.month - 1, parts.day) / MS_PER_DAY2;
}

// src/conversion.ts
var DEFAULT_TIMEZONE = "Asia/Shanghai";
var MS_PER_DAY3 = 864e5;
function toLunar(input, options = {}) {
  const source = normalizeGregorianInput(input);
  const timezone = options.timezone ?? DEFAULT_TIMEZONE;
  const localDate = toTimeZoneDate(source, timezone);
  const { year, info, firstDayTimestamp } = resolveLunarYear(localDate);
  const diffDays = diffDaysFromYearStart(localDate, firstDayTimestamp);
  let accumulatedDays = 0;
  let monthIndex = 0;
  let monthLength = 0;
  const totalSegments = getSegmentCount(info);
  while (monthIndex < totalSegments) {
    monthLength = getSegmentDays(info, monthIndex);
    accumulatedDays += monthLength;
    if (diffDays < accumulatedDays) {
      break;
    }
    monthIndex += 1;
  }
  if (monthIndex === totalSegments) {
    throw new InvalidGregorianDateError("\u65E0\u6CD5\u5339\u914D\u5BF9\u5E94\u7684\u519C\u5386\u65E5\u671F");
  }
  const day = monthLength - (accumulatedDays - diffDays) + 1;
  const { isLeap, displayMonthIndex } = resolveLeapMonth(info, monthIndex);
  const month = displayMonthIndex + 1;
  return {
    lunar: createLunarDate({ year, month, day, isLeapMonth: isLeap }),
    source,
    metadata: { timezone }
  };
}
function toGregorian(input, options = {}) {
  const lunar = createLunarDate(input);
  const timezone = options.timezone ?? DEFAULT_TIMEZONE;
  const info = getYearInfo(lunar.year);
  const { segmentIndex, monthLength } = resolveSegmentIndex(info, lunar.month, lunar.isLeapMonth);
  if (lunar.day > monthLength) {
    throw new InvalidLunarDateError("\u519C\u5386\u65E5\u671F\u8D85\u51FA\u5F53\u6708\u5929\u6570");
  }
  const offsetDays = getAccumulatedDaysBeforeSegment(info, segmentIndex) + (lunar.day - 1);
  const timestamp = getYearStartTimestamp(info) + offsetDays * MS_PER_DAY3;
  const date = alignDateToTimeZone(new Date(timestamp), timezone);
  return {
    date,
    source: lunar,
    metadata: { timezone }
  };
}
function resolveLunarYear(date) {
  let targetYear = date.getUTCFullYear();
  if (targetYear < DATA_YEAR_MIN || targetYear > DATA_YEAR_MAX) {
    throw new InvalidGregorianDateError(`\u4EC5\u652F\u6301\u516C\u5386 ${DATA_YEAR_MIN}-${DATA_YEAR_MAX} \u5E74\u8303\u56F4\u5185\u7684\u65E5\u671F`);
  }
  let info = getYearInfo(targetYear);
  let firstDayTimestamp = getYearStartTimestamp(info);
  if (date.getTime() < firstDayTimestamp) {
    targetYear -= 1;
    if (targetYear < DATA_YEAR_MIN) {
      throw new InvalidGregorianDateError(`\u4EC5\u652F\u6301\u516C\u5386 ${DATA_YEAR_MIN}-${DATA_YEAR_MAX} \u5E74\u8303\u56F4\u5185\u7684\u65E5\u671F`);
    }
    info = getYearInfo(targetYear);
    firstDayTimestamp = getYearStartTimestamp(info);
  }
  return { year: targetYear, info, firstDayTimestamp };
}
function resolveLeapMonth(info, monthIndex) {
  let displayMonthIndex = monthIndex;
  let isLeap = false;
  if (info.hasLeapMonth && info.leapMonthIndex !== null) {
    if (monthIndex === info.leapMonthIndex + 1) {
      isLeap = true;
    }
    if (monthIndex > info.leapMonthIndex) {
      displayMonthIndex -= 1;
    }
  }
  return { isLeap, displayMonthIndex };
}
function resolveSegmentIndex(info, month, isLeap) {
  const zeroBasedMonth = month - 1;
  if (zeroBasedMonth < 0 || zeroBasedMonth > 11) {
    throw new InvalidLunarDateError("\u519C\u5386\u6708\u4EFD\u5FC5\u987B\u4F4D\u4E8E 1-12 \u4E4B\u95F4");
  }
  if (isLeap) {
    if (!info.hasLeapMonth || info.leapMonthIndex === null) {
      throw new InvalidLunarDateError("\u8BE5\u5E74\u4EFD\u65E0\u95F0\u6708");
    }
    if (zeroBasedMonth !== info.leapMonthIndex) {
      throw new InvalidLunarDateError("\u95F0\u6708\u7F16\u53F7\u4E0E\u5F53\u5E74\u6570\u636E\u4E0D\u5339\u914D");
    }
    const segmentIndex2 = info.leapMonthIndex + 1;
    return {
      segmentIndex: segmentIndex2,
      monthLength: getSegmentDays(info, segmentIndex2)
    };
  }
  let segmentIndex = zeroBasedMonth;
  if (info.hasLeapMonth && info.leapMonthIndex !== null && zeroBasedMonth > info.leapMonthIndex) {
    segmentIndex += 1;
  }
  const totalSegments = getSegmentCount(info);
  if (segmentIndex >= totalSegments) {
    throw new InvalidLunarDateError("\u519C\u5386\u6708\u4EFD\u4E0E\u5E74\u8868\u4E0D\u5339\u914D");
  }
  return {
    segmentIndex,
    monthLength: getSegmentDays(info, segmentIndex)
  };
}

// src/format.ts
var STEMS = ["\u7532", "\u4E59", "\u4E19", "\u4E01", "\u620A", "\u5DF1", "\u5E9A", "\u8F9B", "\u58EC", "\u7678"];
var BRANCHES = ["\u5B50", "\u4E11", "\u5BC5", "\u536F", "\u8FB0", "\u5DF3", "\u5348", "\u672A", "\u7533", "\u9149", "\u620C", "\u4EA5"];
var ZODIACS = ["\u9F20", "\u725B", "\u864E", "\u5154", "\u9F99", "\u86C7", "\u9A6C", "\u7F8A", "\u7334", "\u9E21", "\u72D7", "\u732A"];
var MONTH_NAMES = {
  long: ["\u6B63\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u51AC\u6708", "\u814A\u6708"],
  short: ["\u6B63", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D", "\u5341", "\u51AC", "\u814A"]
};
var DAY_NAMES = {
  long: [
    "\u521D\u4E00",
    "\u521D\u4E8C",
    "\u521D\u4E09",
    "\u521D\u56DB",
    "\u521D\u4E94",
    "\u521D\u516D",
    "\u521D\u4E03",
    "\u521D\u516B",
    "\u521D\u4E5D",
    "\u521D\u5341",
    "\u5341\u4E00",
    "\u5341\u4E8C",
    "\u5341\u4E09",
    "\u5341\u56DB",
    "\u5341\u4E94",
    "\u5341\u516D",
    "\u5341\u4E03",
    "\u5341\u516B",
    "\u5341\u4E5D",
    "\u4E8C\u5341",
    "\u5EFF\u4E00",
    "\u5EFF\u4E8C",
    "\u5EFF\u4E09",
    "\u5EFF\u56DB",
    "\u5EFF\u4E94",
    "\u5EFF\u516D",
    "\u5EFF\u4E03",
    "\u5EFF\u516B",
    "\u5EFF\u4E5D",
    "\u4E09\u5341"
  ],
  short: [
    "\u521D\u4E00",
    "\u521D\u4E8C",
    "\u521D\u4E09",
    "\u521D\u56DB",
    "\u521D\u4E94",
    "\u521D\u516D",
    "\u521D\u4E03",
    "\u521D\u516B",
    "\u521D\u4E5D",
    "\u521D\u5341",
    "\u5341\u4E00",
    "\u5341\u4E8C",
    "\u5341\u4E09",
    "\u5341\u56DB",
    "\u5341\u4E94",
    "\u5341\u516D",
    "\u5341\u4E03",
    "\u5341\u516B",
    "\u5341\u4E5D",
    "\u4E8C\u5341",
    "\u5EFF\u4E00",
    "\u5EFF\u4E8C",
    "\u5EFF\u4E09",
    "\u5EFF\u56DB",
    "\u5EFF\u4E94",
    "\u5EFF\u516D",
    "\u5EFF\u4E03",
    "\u5EFF\u516B",
    "\u5EFF\u4E5D",
    "\u4E09\u5341"
  ]
};
var DEFAULT_PREFIX = "\u519C\u5386";
var DEFAULT_LEAP_MARKER = "\u95F0";
var DEFAULT_STYLE = "long";
var DEFAULT_LOCALE = "zh-CN";
function formatLunar(input, options = {}) {
  return formatLunarParts(input, options).map((part) => part.value).join("");
}
function formatLunarParts(input, options = {}) {
  const lunar = createLunarDate(input);
  const normalized = normalizeOptions(options);
  const parts = [];
  if (normalized.locale !== DEFAULT_LOCALE) {
  }
  if (normalized.prefixText) {
    parts.push({ type: "prefix", value: normalized.prefixText });
  }
  if (normalized.includeStemBranch) {
    parts.push({ type: "yearStem", value: getStem(lunar.year) });
    parts.push({ type: "yearBranch", value: getBranch(lunar.year) });
  } else {
    parts.push({ type: "yearNumber", value: String(lunar.year) });
  }
  parts.push({ type: "literal", value: "\u5E74" });
  if (normalized.includeZodiac) {
    parts.push({ type: "literal", value: "\uFF08" });
    parts.push({ type: "yearZodiac", value: getZodiac(lunar.year) });
    parts.push({ type: "literal", value: "\uFF09" });
  }
  const monthText = formatMonth(lunar, normalized);
  parts.push({ type: "month", value: monthText });
  const dayText = formatDay(lunar, normalized);
  parts.push({ type: "day", value: dayText });
  return parts;
}
function normalizeOptions(options) {
  let prefixText;
  if (options.prefix === void 0 || options.prefix === true) {
    prefixText = DEFAULT_PREFIX;
  } else if (options.prefix && typeof options.prefix === "string") {
    prefixText = options.prefix;
  }
  const stemBranch = options.stemBranch ?? true;
  const includeStemBranch = stemBranch === true || stemBranch === "year" || stemBranch === "all";
  const includeZodiac = options.zodiac ?? false;
  const leapMarker = options.leapMarker ?? DEFAULT_LEAP_MARKER;
  const style = options.style ?? DEFAULT_STYLE;
  const locale = options.locale ?? DEFAULT_LOCALE;
  return {
    prefixText,
    includeStemBranch,
    includeZodiac,
    leapMarker,
    style,
    locale
  };
}
function getStem(year) {
  const index = mod(year - 4, STEMS.length);
  return STEMS[index];
}
function getBranch(year) {
  const index = mod(year - 4, BRANCHES.length);
  return BRANCHES[index];
}
function getZodiac(year) {
  const index = mod(year - 4, ZODIACS.length);
  return ZODIACS[index];
}
function formatMonth(lunar, options) {
  const monthNames = MONTH_NAMES[options.style];
  const base = monthNames[lunar.month - 1];
  return `${lunar.isLeapMonth ? options.leapMarker : ""}${base}`;
}
function formatDay(lunar, options) {
  const dayNames = DAY_NAMES[options.style];
  return dayNames[lunar.day - 1];
}
function mod(n, base) {
  return (n % base + base) % base;
}
export {
  InvalidGregorianDateError,
  InvalidLunarDateError,
  LunarError,
  MAX_SUPPORTED_YEAR,
  MIN_SUPPORTED_YEAR,
  NotImplementedError,
  createLunarDate,
  formatLunar,
  formatLunarParts,
  toGregorian,
  toLunar
};
//# sourceMappingURL=index.js.map